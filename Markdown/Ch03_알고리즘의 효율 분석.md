# Ch03 알고리즘의 효율 분석

- 시간 복잡도
    - 알고리즘 성능 지표
    - 입력 크기에 대한 연산 횟수의 상한선
    - 낮으면 낮을수록 좋음
- 1차원 배열 검색
    - 가장 빨리 찾는 경우: 검색 시작 위치에 찾을 값이 바로 있는 경우
    - 가장 늦게 찾는 경우: 아예 찾으려는 값이 없거나 가장 마지막에 위치하는 경우
- 알고리즘 수행 시간을 측정하는 방법
    - 절대 시간을 측정하는 방법(활용X)
        - 말 그대로 시간 측정
        - 실행하여 결과가 나올 때까지의 시간을 측정
    - 시간 복잡도를 측정하는 방법
        - 시간 복잡도는 알고리즘이 시작~끝까지의 연산 횟수임
        - 시간 복잡도는 최악의 경우를 가정하는게 일반적임
        - 종류: 최선, 보통, 최악
            - 1차원 배열(크기 8)검사의 경우 최선은 1번, 최악은 8번(특정적이므로 무의미)
            - 배열 크기가 1이면 최선, 보통 최악이 다 1임
            - 고로 연산 횟수 기준으로 시간 복잡도를 측정하는건 무리가 있음
            - **점근적 표기법**
                - 입력 크기 N에 따른 연산 횟수의 추이를 활용한 시간 복잡도 표현법
- 최악의 경우 시간 복잡도를 표현하는 Big-O 표기법
    - Big-O 표기법: 최악의 경우에 대해 상한선을 활용한 점근적 표기법
    - 연산 횟수 f(x)에 대해 최고차항 계수를 지워 표기
    - 예) f(x)=2x²+3x+5: 시간복잡도 = O(x²)
- 시간 복잡도를 코딩 테스트에 활용하는 방법
    - 문제 조건에 맞는 알고리즘을 선택하라
    - 선택 기준: 컴퓨터의 초당 연산 최대 횟수는 1억번
    - 출제자 의도대로 구현했다면 대부분 코드를 정답 처리할 수 있도록 채점 시간을 충분히 여유있게 지정함
    - 연산 횟수는 1000~3000만 정도로 고려하라
    예) 제한 시간 1초인 문제는 연산 횟수가 3000만이 넘으면 안됨
    - 1초당 각 시간 복잡도별로 허용 가능한 N의 가용 범위
        
        ![스크린샷 2024-11-01 20.49.01.png](Ch03%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%92%E1%85%AD%E1%84%8B%E1%85%B2%E1%86%AF%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20130b4eef2023805aa0a9c253fb906aa2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-01_20.49.01.png)
        
    - 예) 배열 크기 8인 배열 검색에선 시간 복잡도 = O(N)
        - O(N)의 허용 연산 횟수는 ≤ 2000 이므로 데이터 갯수가 이 이하면 알고리즘 사용 가능
- 시간 복잡도 계산해보기
    1. 문제 정의
    2. 연산 횟수 측정
    3. 시간 복잡도 분석
    - 별 찍기 문제
        1. 정의: 숫자 N을 입력받으면 N번째 줄까지 별 1개~N개까지 증가시키며 출력
        2. 연산 횟수 측정: 출력 자체가 연산. 1번째 줄은 1번 연산 ﹒﹒﹒ N번째 줄은 N번 연산
            - 연산 횟수 f(N)=1+2+…+N=N(N+1)/2
        3. 시간 복잡도: O(N²)
    - 박테리아 수명 문제
        1. 문제 정의: 초기 세포 개수가 N일 때 해마다 개수가 이전 새포 개수의 반으로 감소,
        언제 모든 박테리아가 죽는지 계산
        2. 연산 횟수 측정: 현재 개수 N, 1년 뒤 개수 1/2*N ﹒﹒﹒ Y년 후 (1/2)ʸ*N
            - 소멸 시기는 (1/2)ʸ*N ≤ 1인 Y 값
            - Y > log₂N
        3. 시간 복잡도: O(logN)
- 요약
    - 점근적 표기법: 입력 크기에 따른 연산 횟수의 추이를 활용해서 시간 복잡도 표현하는 방법
    - 빅오 표기법: 데이터 개수 N에 대해 연산 횟수를 일반화하고 최고차항 계수를 지워 표현하는 방법